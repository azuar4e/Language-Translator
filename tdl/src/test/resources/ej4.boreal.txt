{ Se debe editar el fichero para hacer las siguientes modificaciones: 
// + cambiarlo por uno de los operadores aritméticos implementados
// operador relacional: cambiarlo por uno de los operadores relacionales implementados 
// and cambiarlo por uno de los operadores lógicos implementados
// eliminar los operadores especiales no implementado
// en la función sent, dejar solamente el case o el if-else implementado y borrar la otra estructura
}

VAR
 bb: boolean;
 s1: string;
 kk: integer;
 pp: integer;
 jj: integer;

function print (kk: integer; s1: integer): string;
begin
	write (kk, ' #');
	if (0 <> s1)	{ Cuando s1 valga 0, esta expresión debe evaluarse como falsa y cuando sea positivo, debe evaluarse como verdadera }
	then   write (s1);
	return ('. ');
end;

function  sent (s: string): integer;
var
	iii: integer;
	ss: string;
	kk: integer;
begin
	ss:=s;
	iii:= 22;
	jj:= 4;
	pp:= 1;
	kk:= 33;
	read (ss);
	s1:=ss;
	writeln (s, s1);
	
	WHILE bb and (iii < kk) do 	{ cambiar la lógica de la condición del bucle para que no sea un bucle infinito, pero conservando un operador relacional y un operador lógico. Tener en cuenta la actualización de iii dentro del bucle}
	begin
		if (bb) then writeln(print (iii, 0));
		iii:= iii+1;
	end;
	
	FOR iii:= kk to 44 do	
	begin
		if (bb) then writeln(print (iii, 0));
	end;

	REPEAT
		if (bb) then writeln(print (iii, 0));
		iii:= iii+1;
	UNTIL bb and (iii > kk);	{ cambiar la lógica de la condición del bucle para que no sea un bucle infinito, pero conservando un operador relacional y un operador lógico. Tener en cuenta la actualización de iii dentro del bucle }
	
	LOOP 
		iii:= iii + 1;
		exit when bb and (iii < kk); { cambiar la lógica de la condición del bucle para que no sea un bucle infinito, pero conservando un operador relacional y un operador lógico. Tener en cuenta la actualización de iii dentro del bucle }
		if (bb) then writeln(print (iii, 0));
	end;
	
	return jj;
end;

function  Recursivo (nnn: integer): integer;
var resul: integer;
begin
	kk:= kk + 11;
	writeln(print (nnn, kk));
	if (1 < nnn) then	return 1;	{ poner la condición para que se cumpla tras 3 o 4 iteraciones }
	resul:= nnn + Recursivo (nnn + pp);
	writeln(print (nnn, kk));
	return resul;
end;

function operador: integer;	{dejar solo la línea con el operador implementado}
var sss: string;
begin
	write (kk,'**3='); return kk**3);
	sss:= 'Eres ' + s1; writeln (sss); return 0;
	if (kk IN (1, 3, 5, 7, 9, jj )) then return (2);
	return MIN (jj, 22, 33, kk, 44, pp);
	return MAX (jj, 15, 11, kk, 00, pp);
end;

program main;
var cinco: integer;
begin
	s1:= 'Introduce un digito. ';
	write (s1);
	cinco:= 5;
	bb:= 0 < cinco; { cambiar los valores para que bb siempre valga true en función del operador }
	read (kk);
	writeln ('Escribe tu nombre. ');
	writeln (sent('Hola, '));
	writeln(operador);
	kk:=11;
	writeln(print (Recursivo(jj), kk));
	writeln ('Adios, ', (s1));
end;