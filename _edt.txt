Terminales = {program, id, ;, var, :, boolean, integer, string, (, ), begin, end, if, then, else, :=, entero, write, writeln, read, return, ,, and, =, *, true, false, min}
NoTerminales = {P, R, PP, PR, PF, D, DD, T, A, AA, Bloque, C, B, EE, THEN, S, SS, LL, L, Q, V, W, Y, E, G, H, I, Z, X}

meterle acciones semanticas a las reglas y quitar las reglas que no necesitemos
los que tienen un tab de mas hay que quitarlos, pero ver a q otras reglas afecta
antes de quitarlas


EdT = {
    P -> D R
    R -> PP R1
    R -> PF R1
    R -> PR R1
    R -> Lambda
    PP -> program id ; D Bloque ;
    PR -> procedure id A ; D Bloque ;
    PF -> function id A : T ; D Bloque ;
    D -> var id : T ; DD
    D -> Lambda
    DD -> id : T ; DD1
    DD -> Lambda
    T -> boolean
    T -> integer
    T -> string
    A -> ( X id : T AA )
    A -> Lambda
    AA -> ; X id : T AA1
    AA -> Lambda
    Bloque -> begin C end
    C -> B C1
    C -> Lambda
    B -> if EE then S
    EE -> E
    B -> S
    B -> if EE then Bloque ;
    B -> if THEN else Bloque ;
    THEN -> EE then Bloque ;
    S -> write LL ;
    S -> writeln LL ;
    S -> read ( V ) ;
    S -> id SS ;
    S -> return Y ;
    SS -> := E ;
    SS -> LL ;
    LL -> ( L )
    LL -> Lambda
    L -> E Q
    Q -> , E Q1
    Q -> Lambda
    V -> id W
    W -> , id W
    W -> Lambda
    Y -> E
    Y -> Lambda
    E -> E1 and G
    E -> G
    G -> G1 = I
    G -> I
    I -> I1 * Z
    I -> Z
    Z -> entero
    Z -> cadena
    Z -> true
    Z -> false
    Z -> id LL
    Z -> ( E )
    Z -> min ( L )
    X -> var
    X -> Lambda
}

-----------------------------------------------------------
--------------- con acciones semanticas -------------------
-----------------------------------------------------------

EdT = {
    P -> D R {}
    R -> PP R1 {}
    R -> PF R1 {}
    R -> PR R1 {}
    R -> Lambda {}
    PP -> program id ; D Bloque ; {}
    PR -> procedure id A ; D Bloque ; {}
    PF -> function id A : T ; D Bloque ; {}
    D -> var id : T ; DD {}
    D -> Lambda {}
    DD -> id : T ; DD1 {}
    DD -> Lambda {}
    T -> boolean {}
    T -> integer {}
    T -> string {}
    A -> ( X id : T AA ) {}
    A -> Lambda {}
    AA -> ; X id : T AA1 {}
    AA -> Lambda {}
    Bloque -> begin C end {}
    C -> B C1 {}
    C -> Lambda {}
    B -> { B.despues = nuevaetiq() } if EE { emite('if',EE.lugar,'=',1,'goto',sig_instr+1); emite('goto', B.despues)} then S
    EE -> E { EE.lugar = E.lugar }
    B -> S {}
    B -> if EE then Bloque ; {}
    B -> if THEN else Bloque ; {}
    THEN -> EE then Bloque ; {}
    S -> write LL ; {}
    S -> writeln LL ; {}
    S -> read ( V ) ; {}
    S -> id SS ; {}
    S -> return Y ; {}
    SS -> := E ; {}
    SS -> LL ; {}
    LL -> ( L ) {}
    LL -> Lambda {}
    L -> E Q {}
    Q -> , E Q1 {}
    Q -> Lambda {}
    //esto es del read y no se como cojones va
    V -> id W {}
    W -> , id W {}
    W -> Lambda {}
    Y -> E { Y.lugar = E.lugar }
    Y -> Lambda { Y.lugar = vacio }
    E -> { E.lugar = nuevatemp() } E1 and { emite('if',E1.lugar,'=','0','goto',sig_instr+3) } E2 { emite('if',E1.lugar,'=','0','goto',sig_instr+2); emite(E.lugar, ':=', 1); emite('goto', sig_instr+1); emite(E.lugar, ':=', 0) }
    E -> G { E.lugar = G.lugar }
    G -> G1 = I { emite(); emite(G.lugar, ':=', 1); emite('goto', sig_instr+1); emite(G.lugar, ':=', 0) }
    G -> I  { G.lugar = I.lugar }
    I -> I1 * Z { emite(MUL, I1.lugar, Z.lugar, I.lugar) }
    I -> Z { I.lugar = Z.lugar }
    Z -> entero { Z.lugar = entero.valor }
    Z -> cadena { Z.lugar = cadena.valor }
    Z -> id LL
    Z -> ( E )
    Z -> min ( L ) 
    X -> var
    X -> Lambda
}